
i = 6 
charsprinted = 9 


convertTOkesn()
buffer --> portion 
i = 0; 
buffer[0] = {I}
i = 1
buffer[1] = {t}
inf.get == ' ' --> c = ' ' 
exit while lop 
buffer[1] = '\0' 

asdfa <P>
qwert

012345678

i = 6
buffer = "<P>" 
____________________________________________________________
input: asdfa and
output: asdfa asdfa

arrage{ 
    portion <--- asdfa
    prev portion = asdfa
    i = 4 
    charsprinted= 5
    outf << asdfa + " " 
    charsprint = 6

2. 
    prevportion = asdfa
    portion = and

    charsPrinted  = 9
    9 > 6 --> true  
        outf<< prevPortion 
        outf << \n 

}

the problem is that preve portion is printing twice when it shoudl be printing once
It is an inssure with the first loop case, if the loop havd more input 
than output 
____________________________________________________________
input: 
It always does seem to me that I am doing more work than
  I should do. It is not that I object to the work, mind you;
I like work: it fascinates me. <P>      I can sit and look at it for hours.
output: 
It always does seem to me that I am doing
more work than I should  do. It is not
that I object to the work, mind you; I
like  work: it fascinates  

<P> I can sit and look at it for  hours. 

trace: 
prev portion = fascinates
portion = me. 
len =3 
charsprinted = 22 + 3 = 25
outf<< fascinates + " "

prev poriton = me. 
portion = <P>
outf me.  
outf /n/n 
prev poriton = <P> 

poriton = I 
____________________________________________________________
prevPortion = It
char printed = 2 
portion. = always
charprinted = 8 
8 > 7 --> true 
outf << It. + \n
charsprinted = 2 
prevporiton = always


portion = Error
outf << always.  + '\n'

<<<<<<
prevPortion = It
char printed = 2 
portion. = always
charprinted = 8 
8 > 7 --> true 
outf << It. + \n
charsprinted = 2 
prevporiton = always


portion = Error
outf << always.  + '\n'



what isf I incremented charsprinted when  I fucking rint
what if I check prevportion length when checking for overflow --> 
can know if next will overflow thus can know when last word in line --> 
print bad spaces 

if I have charsPrinted be the future count I have to do shenanigans 
____________________________________________________________
cases: -so
so-sdf
so--dsdf


hi <P>
hi |


prevPortion = hi
portion = <P> 
outf<< hi | 

** I need to check 
prevPortion = <P> 
Portion = EOF
break; 


hi <P> <P> <P> 
hi 


|
prevportion = hi 
poriton = <P> 
charcount = 2 
outf << hi |
prevportion = <P> 
portion = <P> 
outf << \n\n

that has erorr where it doesnt check EOF

if next portion is p 
continue 
if prev poriton is P and curr portion is not P or EOF
write two newline


functionality: 
if 2/more P print onen P if not EOF after Ps 


if P hit trigger flag 
if flag and P hit 
continue 
if flag and EOF hit
  dont do any added newline
else if flag and word
  write two newline

if()

____________________________________________________________
input 20, string

trac: 
paragraphfound = false
prevportion = hi 
charcount = 3
portion = <P>
charcount = 6 

paragraphfound = false

edit: 
paragraph found 


____________________________________________________________
//     //! set paragraph found 
    //     if(strcmp(prevPortion, "<P>") == 0){
    //         paragraphFound = true;
    //         charCount += 4; // space + 3
    //     }
    //     cout << "paragraph Found: " << paragraphFound << endl;
    //     if (strcmp(portion, "<P>") == 0 && paragraphFound)
    //     {
    //         continue; 
    //         // cerr << "Paragraph found" << endl;
    //         //outf << prevPortion;
    //         outf << "\n\n";
    //         charCount = 0;
    //         paragraphFound = true;
    //     }


    //     //! process words
    //     else if (strcmp(prevPortion, "<P>") != 0)
    //     {
    //         int len;
    //         len = strlen(portion);
    //         int prevlen;
    //         prevlen = strlen(prevPortion);
    //         // check for overflow:
    //         // cerr << "charCount: " << charCount << " LEN: " << len << endl;
    //         // cerr << charCount << ',' << lineLength << endl;
    //         handleOverflow(prevPortion, lineLength, charCount, outf, overflow);
    //         charCount += len; // i is index, leng
    //         if (charCount > lineLength)
    //         {
    //             outf << prevPortion;
    //             outf << '\n';
    //             charCount = len;
    //         }
    //         //if paragraph found and word next output two newline
    //         if(paragraphFound == true){
    //             outf << "\n\n";
    //         }
    //         // cerr << "Last index of portion: " << i << " with val " << portion[i] << endl;
    //         else if (prevPortion[prevlen - 1] == '.' || prevPortion[prevlen - 1] == '?' || prevPortion[prevlen - 1] == ':')
    //         {
    //             outf << prevPortion << "  ";
    //             charCount += 2;
    //         }
    //         else
    //         {
    //             outf << prevPortion << " ";
    //             charCount++; // gets the whitespace
    //         }
    //         paragraphFound = false;
    //     }
    //     strcpy(prevPortion, portion);
    // }
    // cerr << '\n';
    // // cerr << "Total Chars Printed: " << charCount << endl;
    ____________________________________________________________
    prevportion= asd;flaskdjf
    ()handleOverflow
    j = 12
    12 > 5 == true
    temp = asd;f
    outf << temp << \n
    remain = 7 

    ++++++
    hi. my name? is charlie. .
PSEUDO CODE REASONING
set paragraphFound to true is prev is <P> 
if portion and pFound continue

____________________________________________________________
trace: 
prevPoriton = CS31 
portion = <P> 
paragraphFound = false
nextIsParagraph = true; 
14< 20


prevPortion = 12345
charsprinted = 5
portion = 123456
5 + 6 + 1 < 18
outf << 12345
charsprinted += 5 + 1
charsprinted = 11

error: 
charsprinted initally set to length of first word. 
however length and space is added to it again during puntuation
after that it is filename
need intial set to confirm line spacing of first word
solve 


confusion: 
if ever hit <P> set flag, if next is P and flag just continue
** however we do not save word before <P> sequence 

--
1st loop ())(()())
prev portin = This
charsPrinted = 4
portion = is
prev len = 4
spacing = 1
if(4 + 2 + 1 > 7)
charsprinted = 9 
chartsprinted = 5
firsrun = false
outf << "This" 
outf << " " 
prevPortion = is
portion = a 
prevlen = 2 
 + 5  + 1 > 7 
outf << prevPortion + newline
charsprint = 0 


1st loop ())(()())
prev portin = This
charsPrinted = 4
portion = is
prev len = 4
spacing = 1
charsprinted += 2
if(6 + 1 > 7)
charsprinted = 11
chartsprinted = 7
firsrun = false
outf << "This" 
outf << " " 
prevPortion = is
portion = a 
prevlen = 2
7  + 1 > 7 
outf << prevPortion + newline
charsprint = 0 


overflow <P> 
two newline @ <P>

