
i = 6 
charsprinted = 9 


convertTOkesn()
buffer --> portion 
i = 0; 
buffer[0] = {I}
i = 1
buffer[1] = {t}
inf.get == ' ' --> c = ' ' 
exit while lop 
buffer[1] = '\0' 

asdfa <P>
qwert

012345678

i = 6
buffer = "<P>" 
____________________________________________________________
input: asdfa and
output: asdfa asdfa

arrage{ 
    portion <--- asdfa
    prev portion = asdfa
    i = 4 
    charsprinted= 5
    outf << asdfa + " " 
    charsprint = 6

2. 
    prevportion = asdfa
    portion = and

    charsPrinted  = 9
    9 > 6 --> true  
        outf<< prevPortion 
        outf << \n 

}

the problem is that preve portion is printing twice when it shoudl be printing once
It is an inssure with the first loop case, if the loop havd more input 
than output 
____________________________________________________________
input: 
It always does seem to me that I am doing more work than
  I should do. It is not that I object to the work, mind you;
I like work: it fascinates me. <P>      I can sit and look at it for hours.
output: 
It always does seem to me that I am doing
more work than I should  do. It is not
that I object to the work, mind you; I
like  work: it fascinates  

<P> I can sit and look at it for  hours. 

trace: 
prev portion = fascinates
portion = me. 
len =3 
charsprinted = 22 + 3 = 25
outf<< fascinates + " "

prev poriton = me. 
portion = <P>
outf me.  
outf /n/n 
prev poriton = <P> 

poriton = I 
____________________________________________________________
prevPortion = It
char printed = 2 
portion. = always
charprinted = 8 
8 > 7 --> true 
outf << It. + \n
charsprinted = 2 
prevporiton = always


portion = Error
outf << always.  + '\n'

<<<<<<
prevPortion = It
char printed = 2 
portion. = always
charprinted = 8 
8 > 7 --> true 
outf << It. + \n
charsprinted = 2 
prevporiton = always


portion = Error
outf << always.  + '\n'



what isf I incremented charsprinted when  I fucking rint
what if I check prevportion length when checking for overflow --> 
can know if next will overflow thus can know when last word in line --> 
print bad spaces 

if I have charsPrinted be the future count I have to do shenanigans 
____________________________________________________________
cases: -so
so-sdf
so--dsdf


hi <P>
hi |


prevPortion = hi
portion = <P> 
outf<< hi | 

** I need to check 
prevPortion = <P> 
Portion = EOF
break; 


hi <P> <P> <P> 
hi 


|
prevportion = hi 
poriton = <P> 
charcount = 2 
outf << hi |
prevportion = <P> 
portion = <P> 
outf << \n\n

that has erorr where it doesnt check EOF

if next portion is p 
continue 
if prev poriton is P and curr portion is not P or EOF
write two newline


functionality: 
if 2/more P print onen P if not EOF after Ps 


if P hit trigger flag 
if flag and P hit 
continue 
if flag and EOF hit
  dont do any added newline
else if flag and word
  write two newline

if()

____________________________________________________________
input 20, string

trac: 
paragraphfound = false
prevportion = hi 
charcount = 3
portion = <P>
charcount = 6 

paragraphfound = false

edit: 
paragraph found 

________
this is a test (7)

overflow = false
prevportion = this
charcount = 5
poriton = is
enter check branch
charcount = 7
8 > 7 
this

prevportion = is 
poriton = this
________
Hello world <P>

paragraphfound = false
prevportion = world
charcount = 6
portion = <P> 
prevporirotn = <P> 
**
portion = this
paragraph found = true




charcount = 10
prevportion = this
continue 
poriton = is
prevportion = this
prevpar = false

prevportion = is
continue

how do I save P 
if portion is <P> and prev is not paragraph
    wrtie two newline

want: 
now paragraph trigger if next poriton is EOF

if portion is <P> and prev is not paragraph then output lines


example: 
hi <P> 