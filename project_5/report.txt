a. 
One of the biggest obstacles was handling the case of consecutive paragraphs. I started by setting a flag to true if the next portion is a <P>. I did this because I wanted to bypass my space/punctuation writing code if so. However this did not work when I came to implement the functionality where multiple <P>s strung together act as one <P>. To solve this, I set a flag true based on the current portion, and stepped out of the loop (continue) if the next is a portion. When finally the next is not a portion, It then enters two newlines. However, I realized my punctuation would now happen when I didnâ€™t want it to because the punctuation code would not be in the branch (implicitly, ie passed some earlier check) when the next is not a <P>. Finally, by explicitly adding a statement to skip punctuation if next is <P>, I was able to properly detect a sequence of <P>s and also skip adding spaces if the next portion is a <P>. 



b. Pseudo code for project: 
convertTokens(){ 
    check if EOF
    while char is space, skip
    while char is not space, tab, newline
        save to buffer
        if char is -
            terminate buffer
    terminate buffer
    return true if success, false if EOF

        
}
arrange(){ 
    load prevtoken with first work
    loop continuosly: 
        attempt to get next token
          cant-->  write prev token and exit loop  
          can --> 
          check if prevtoken overflows, call handleOverflow
          if prevtoken last on line
            write prevtoken skip adding spaces, add newline
          else: 
            check if paragraph + double paragraph sequence, handle to spec. 
            else if write spaces based on punctuation 
            increment counter tracking chars printed. 
            update prevToken to currentToken
}

handleOverflow(){ 
    if portion > linelength 
    split portion up to linelength 
    output that and newline
    save rest of portion to argument passed
}

c.test cases: 
1.  Input: s-----  | (linelength = 3) | ##testing hypen splitting
2. Input: <P> asdf |(linelength = 20) |  ## fist portion is <P> 
3. Input: asdf <P> hi | (linelength = 20) |  ## testing normal paragraph
4. Input: asdf <P> <P> <P> hi | (lineLength =20) |## testing sequence paragraph
5. Input: 
Let's
    check    what
 happens.  <P>

Wow. | (lineLength =20) |## testing tabs and newline
6. Input: 12345 <P> | (linelength = 7 ) | ## testing not treating <P> as portion
6. Input: <P> | (linelength =  10) | ## testing edge case of only <P> 
6. Input: asdfasdf| (linelength =  -4) | ## testing return value 1 
6. Input: | (linelength =  ) | ## testing
6. Input: | (linelength =  ) | ## testing
6. Input: | (linelength =  ) | ## testing
6. Input: | (linelength =  ) | ## testing
